<!-- TOC -->

- [1. Example 1 从一个数组里找到最大值](#1-example-1-从一个数组里找到最大值)
- [2. Example 2 一个数组是否有重复元素](#2-example-2-一个数组是否有重复元素)

<!-- /TOC -->

Mathematical Analysis of Nonrecursive Algorithms非递归算法的效率分析

非递归算法的效率分析的基本步骤:
1. 确定一个参数来表示input size
2. 确定算法的basic operation(一般是在loop里面)
3. 确定basic operation的数量跟input size是否关联, 是否要区分best case, worst case, average case
4. 用sum表达式来表达basic operation的数量
5. 用公式、定理来确定order of growth

这里举几个例子:
<a id="markdown-1-example-1-从一个数组里找到最大值" name="1-example-1-从一个数组里找到最大值"></a>
### 1. Example 1 从一个数组里找到最大值
  
    ```
    ALGORITHM max value of a array[0, 1, 2, ..., n-1]
    // Input: an array A[0...n-1] of real numbers
    // Output: the max value of A
    maxv = A[0]
    for i in 1 to n - 1:
      if A[i] > maxv:
        maxv = A[i]
    return maxv
    ```
    我们看到这个算法, 首先把第一个元素赋值给maxv, 接下来是一个loop, 共有n-1次循环, 每次循环里面有一次比较和一次赋值(是否赋值需要根据比较情况而定)  
    我们可以把循环里面的比较算作basic operation, 因为这个比较是最主要的操作  
    然后我们可以发现, 循环的次数是跟input size没关系的, 也就是说, 在best case、average case、worst case情况下, 循环次数都是一样的, 所以我们不用区分这三种情况  
    这样, 我们可以得出这个算法的basic operation的数量是:
    $$C(n) = \sum_{1}^{n-1}1 = n - 1 \in \Theta(n)$$


<a id="markdown-2-example-2-一个数组是否有重复元素" name="2-example-2-一个数组是否有重复元素"></a>
### 2. Example 2 一个数组是否有重复元素

```
ALGORITHM uniqueElements(A[0...n-1])
array A[0...n-1] has duplicate elements
// Input: an array A[0...n-1] of real numbers
// Output: false if A has duplicate elements, true otherwise
for i in 0 to n-2:
  for j in i+1 to n-1:
    if A[i] == A[j]:
      return false
  return true
```
input size是n  
basic operation是loop里面的比较